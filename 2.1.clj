;; Задача 2.1: численное интегрирование
;; Реализовать функцию (оператор), принимающую аргументом функцию от одной переменной f и
;; возвращающую функцию одной переменной, вычисляющую (численно) выражение.
;; Оптимизировать с использованием мемоизации для задач типа построения графиков (т.е.
;; многократный вызов функции в разных точках). Использовать метод трапеций с постоянным шагом.
;; Показать прирост производительности с помощью time. Обеспечить покрытие тестами. 

;; Как я понимаю условие: нужно использовать memoize; если есть рекурсивные функции, то для
;; оптимизации нужно использовать хвостовую рекурсию. Шаг можно считать константой 1/1000.

;; Подход к решению (код ниже):
;; Функция mean считает среднее двух чисел
;; Функция integral_part принимает функцию, размер шага и номер шага i и считает площадь трапеции
;; между (i-1)-м и i-м шагом (отсчитывая шаги от нуля). Работает за константное время, не считая
;; время вызова самой функции.
;; Функция integral_rough принимает функцию, размер шага, целочисленное количество шагов и
;; дополнительный параметр, который обозначает прибавляемую к ответу константу и используется
;; в рекурсивных вызовах. Считает интеграл функции, делая заданное количество шагов от нуля.
;; Работает рекурсивно (через recur).
;; Функция integral принимает функцию и неотрицательный аргумент и считает интеграл с размером
;; шага 1/1000. Вызывает integral_rough с мемоизацией и прибавляет площадь трапеции, полученной
;; остатком от деления аргумента на шаг.

;; Модульное тестирование:
;; В среде https://www.jdoodle.com/ не импортируется "clojure.test :as test", поэтому не использую
;; эту библиотеку, думаю что это несущественно. Задаю функцию almost_equal, сравнивающую числа
;; с допустимой погрешностью 1/1000. Сначала тестирую эту функцию на 2 примерах, потом тестирую
;; функцию integral на нескольких примерах. Тестирование функций для внутреннего использования,
;; таких как integral_part и integral_rough, кажется излишним. Если работает интеграл, значит
;; работают и эти функции. Тем более эти функции можно было бы задать в letfn внутри integral,
;; и тогда их нельзя было бы протестировать.

;; Производительность:
;; Непонятно, как сделать мемоизацию рекурсивной функции integral_rough. Она считает значение
;; на основе предыдущего значения (так же, как факториал). Просто "memoize integral_rough"
;; по-видимому не работает, что видно из тестов ниже: если интеграл от 500 один раз посчитан, то
;; в следующий раз он считается очень быстро, но интеграл от 501 считается так же долго.
;; Если взять аналогичный пример из лекций:

;; (defn fact [n]
;;   (if (> n 1)
;;     (reduce + (range 2 (inc n)))
;;     1))
;; (def fact-mem (memoize fact))

;; В котором я заменил умножение на сложение, чтобы не возникал integer overflow, то мемоизация
;; функции fact в лекциях дает следующие результаты:

;; (time (fact-mem 100))
;; (time (fact-mem 100))

;; "Elapsed time: 1.087113 msecs"
;; "Elapsed time: 0.032623 msecs"

;; Я смог воспроизвести это поведение, однако следующий код:

;; (time (fact-mem 100))
;; (time (fact-mem 101))

;; Не показывает никакого прироста скорости, хотя на основе значения (fact 100) вычислить
;; (fact 101) можно было бы за один шаг. Это говорит о том, что даже в примере из лекций
;; мемоизация работает не до конца, соответственно и у меня тоже.

;; UPD: в задаче 2.2 эта проблема решается


(defn mean [x1 x2]
  (/ (+ x1 x2) 2))

(defn integral_part [func step step_number]
    (let [x2 (* step step_number) x1 (- x2 step)] (* step (mean (func x1) (func x2)))))

(defn integral_rough [func step steps tmp]
    (if (== steps 0) tmp (recur func step (- steps 1) (+ tmp (integral_part func step steps)))))

(defn integral [func]
  (let [step 1/1000
        integral_rough (memoize integral_rough)]
    (fn [x] (let [steps (quot x step), tail (rem x step)]
	  (+ (integral_rough func step steps 0) (* tail (mean (func (- x tail)) (func x))))))))

; модульные тесты

(defn zero_fn [x] 0)
(defn x_fn [x] x)
(defn x_pow_2_fn [x] (* x x))

(def zero_fn_integral (integral zero_fn))
(def x_fn_integral (integral x_fn))
(def x_pow_2_fn_integral (integral x_pow_2_fn))

(defn almost_equal [x1 x2]
    (< -1/1000 (- x1 x2) 1/1000))

(println (almost_equal 0 -0.00001))
(println (almost_equal 1.0 1.00001))
(println (almost_equal 0 (zero_fn_integral 0)))
(println (almost_equal 0 (zero_fn_integral 1)))
(println (almost_equal 0 (x_fn_integral 0)))
(println (almost_equal 1/2 (x_fn_integral 1)))
(println (almost_equal 1/3 (x_pow_2_fn_integral 1)))
(println (not= (x_fn_integral 1) (x_fn_integral 1.00001)))

; тесты производительности

(time (x_pow_2_fn_integral 500))
(time (x_pow_2_fn_integral 500))
(time (x_pow_2_fn_integral 501))